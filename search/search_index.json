{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Krill","text":"<p>Modern DAG orchestrator for robotics: Build on Rust \ud83e\udd80</p> <p> </p>"},{"location":"#why-krill","title":"Why Krill?","text":"<p>Built for Robotics</p> <p>Krill is an orchestrator designed specifically for robotics, built to manage the real-world complexity of modern robotic systems.</p> <p>ROS / ROS 2 has become a de-facto standard, and Docker is increasingly adopted by roboticists. But once systems grow beyond a single machine, mixing native processes, containers, hardware drivers, and launch logic quickly becomes brittle.</p> <p>Krill bridges this gap by providing a unified way to compose, run, and operate complex robotics stacks \u2014 from laptops to production robots.</p> <p>What Krill Solves</p> <p>One tool. Your entire robotics stack.</p> <ul> <li> <p>ROS 2 Native   First-class support for packages, launch files, lifecycle nodes, and ROS-centric workflows</p> </li> <li> <p>Docker &amp; Pixi Ready   Mix containerized, virtual-env, and native workloads in a single recipe</p> </li> <li> <p>Smart Orchestration   DAG-based dependency management ensures deterministic startup, shutdown, and recovery</p> </li> <li> <p>Production-Grade Observability   Built-in health checks, status propagation, and automatic restart semantics</p> </li> <li> <p>Policy-Driven Operation   Encode operational constraints, safety rules, and system invariants as policies \u2014 not scripts</p> </li> </ul> <p>From local development to production robots \u2014 one configuration, zero rewrites.</p> \u26a1 Low overhead \u2014 native Rust daemon  \ud83d\udd12 Safety aware \u2014 critical service semantics"},{"location":"#features","title":"Features","text":"<ul> <li> <p> TUI integration</p> <p>Rich text user interface (TUI) for managing and monitoring processes. The TUI offers a clear and intuitive way to view and interact with your robotics system</p> </li> <li> <p> ROS2 Native</p> <p>First-class support for ROS2 packages, and launchers. Either natively supported, via Docker, or via Pixi</p> </li> <li> <p> DAG Orchestration</p> <p>Manage complex process dependencies with ease</p> </li> <li> <p> Health Monitoring</p> <p>Real-time process health checks and automatic recovery</p> </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"Prerequisites <ul> <li>Just installed</li> <li>Cargo installed</li> <li>Pixi installed (not mandatory, but usefulfor running examples)</li> </ul> Install <pre><code>just install\n</code></pre> Configure krill.yaml<pre><code>services:\n  ros_talker:\n    execute:\n      type: pixi\n      task: talker\n      working_dir: ./ros2\n    dependencies: []\n  ros_listener:\n    execute:\n      type: pixi\n      task: listener\n      working_dir: ./ros2\n    dependencies:\n      - ros_talker\n</code></pre> Run <pre><code>krill up krill.yaml\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started \u2192</li> <li>Configuration Guide \u2192</li> <li>Examples \u2192</li> <li>Quick Reference \u2192</li> </ul>"},{"location":"configuration/","title":"Krill Configuration Guide","text":"<p>Complete reference for Krill recipe configuration files.</p>"},{"location":"configuration/#table-of-contents","title":"Table of Contents","text":"<ul> <li>File Structure</li> <li>Top-Level Fields</li> <li>Service Configuration</li> <li>Execute Types</li> <li>Health Checks</li> <li>Policies</li> <li>Dependencies</li> <li>Complete Example</li> </ul>"},{"location":"configuration/#file-structure","title":"File Structure","text":"<p>Krill uses YAML configuration files (recipes) to define your service orchestration:</p> <pre><code>version: \"1\"\nname: my-workspace\nlog_dir: ~/.krill/logs\nenv:\n  KEY: value\n\nservices:\n  service-name:\n    execute: {...}\n    dependencies: [...]\n    health_check: {...}\n    policy: {...}\n    critical: false\n    gpu: false\n</code></pre>"},{"location":"configuration/#top-level-fields","title":"Top-Level Fields","text":""},{"location":"configuration/#version-required","title":"<code>version</code> (required)","text":"<p>Type: <code>string</code> Value: <code>\"1\"</code></p> <p>Schema version. Currently only version <code>\"1\"</code> is supported.</p> <pre><code>version: \"1\"\n</code></pre>"},{"location":"configuration/#name-required","title":"<code>name</code> (required)","text":"<p>Type: <code>string</code> Pattern: <code>^[a-zA-Z0-9_-]+$</code></p> <p>Workspace name used in process naming. Must contain only alphanumeric characters, hyphens, and underscores.</p> <pre><code>name: autonomous-robot\n</code></pre>"},{"location":"configuration/#log_dir-optional","title":"<code>log_dir</code> (optional)","text":"<p>Type: <code>string</code> Default: System default location</p> <p>Directory for log files. Supports tilde (<code>~</code>) expansion.</p> <pre><code>log_dir: ~/.krill/logs\n</code></pre>"},{"location":"configuration/#env-optional","title":"<code>env</code> (optional)","text":"<p>Type: <code>object</code> Default: <code>{}</code></p> <p>Global environment variables applied to all services.</p> <pre><code>env:\n  ROS_DOMAIN_ID: \"42\"\n  LOG_LEVEL: \"info\"\n  PYTHONUNBUFFERED: \"1\"\n</code></pre>"},{"location":"configuration/#service-configuration","title":"Service Configuration","text":"<p>Each service is defined under the <code>services</code> key with a unique name.</p>"},{"location":"configuration/#service-name","title":"Service Name","text":"<p>Pattern: <code>^[a-zA-Z0-9_-]+$</code></p> <p>Must contain only alphanumeric characters, hyphens, and underscores.</p> <pre><code>services:\n  my-service:  # Valid\n    # ...\n\n  camera_0:    # Valid\n    # ...\n</code></pre>"},{"location":"configuration/#service-fields","title":"Service Fields","text":"Field Type Required Default Description <code>execute</code> ExecuteConfig Yes - How to run the service <code>dependencies</code> Dependency[] No <code>[]</code> Services this depends on <code>health_check</code> HealthCheck No <code>null</code> Health monitoring config <code>policy</code> Policy No See Policies Restart and timeout settings <code>critical</code> <code>boolean</code> No <code>false</code> Trigger emergency stop on failure <code>gpu</code> <code>boolean</code> No <code>false</code> Validate GPU availability before start"},{"location":"configuration/#example-service","title":"Example Service","text":"<pre><code>services:\n  navigation:\n    execute:\n      type: ros2\n      package: nav2_bringup\n      launch_file: navigation_launch.py\n    dependencies:\n      - slam: healthy\n    critical: true\n    gpu: false\n    health_check:\n      type: http\n      port: 8080\n      path: /health\n    policy:\n      restart: always\n      max_restarts: 5\n      restart_delay: 2s\n      stop_timeout: 10s\n</code></pre>"},{"location":"configuration/#execute-types","title":"Execute Types","text":"<p>The <code>execute</code> field defines how a service runs. Four types are supported:</p>"},{"location":"configuration/#pixi","title":"Pixi","text":"<p>Runs tasks from Pixi (Python package manager).</p> <p>Fields:</p> Field Type Required Description <code>type</code> <code>\"pixi\"</code> Yes Execute type <code>task</code> <code>string</code> Yes Pixi task name <code>environment</code> <code>string</code> No Pixi environment (defaults to service name) <code>stop_task</code> <code>string</code> No Graceful stop task <code>working_dir</code> <code>string</code> No Working directory <p>Example:</p> <pre><code>execute:\n  type: pixi\n  task: start-server\n  environment: production\n  stop_task: cleanup\n  working_dir: ./services/api\n</code></pre>"},{"location":"configuration/#ros2","title":"ROS2","text":"<p>Launches ROS2 packages.</p> <p>Fields:</p> Field Type Required Description <code>type</code> <code>\"ros2\"</code> Yes Execute type <code>package</code> <code>string</code> Yes ROS2 package name <code>launch_file</code> <code>string</code> Yes Launch file name <code>launch_args</code> <code>object</code> No Launch arguments (key-value pairs) <code>stop_task</code> <code>string</code> No Optional Pixi stop task <code>working_dir</code> <code>string</code> No Working directory <p>Example:</p> <pre><code>execute:\n  type: ros2\n  package: nav2_bringup\n  launch_file: navigation_launch.py\n  launch_args:\n    use_sim_time: \"false\"\n    map: \"/maps/warehouse.yaml\"\n    params_file: \"config/nav2_params.yaml\"\n</code></pre>"},{"location":"configuration/#docker","title":"Docker","text":"<p>Runs containerized services.</p> <p>Fields:</p> Field Type Required Description <code>type</code> <code>\"docker\"</code> Yes Execute type <code>image</code> <code>string</code> Yes Docker image name <code>volumes</code> <code>string[]</code> No Volume mounts (<code>host:container</code> or <code>host:container:ro</code>) <code>ports</code> <code>string[]</code> No Port mappings (<code>host:container</code>) <code>privileged</code> <code>boolean</code> No Run in privileged mode (default: <code>false</code>) <code>network</code> <code>string</code> No Network mode (<code>bridge</code>, <code>host</code>, etc.) <p>Example:</p> <pre><code>execute:\n  type: docker\n  image: ghcr.io/robotics/perception:v2.1\n  volumes:\n    - \"/dev/video0:/dev/video0\"\n    - \"./models:/app/models:ro\"\n  ports:\n    - \"8080:8080\"\n    - \"9090:9090\"\n  privileged: true\n  network: host\n</code></pre>"},{"location":"configuration/#shell","title":"Shell","text":"<p>Executes validated shell commands.</p> <p>Fields:</p> Field Type Required Description <code>type</code> <code>\"shell\"</code> Yes Execute type <code>command</code> <code>string</code> Yes Shell command (validated for safety) <code>stop_command</code> <code>string</code> No Graceful stop command <code>working_dir</code> <code>string</code> No Working directory <p>Safety: Shell commands are validated and reject pipes (<code>|</code>), redirections (<code>&gt;</code>, <code>&lt;</code>), command substitution (<code>`</code>), and other dangerous patterns.</p> <p>Example:</p> <pre><code>execute:\n  type: shell\n  command: python -m http.server 8000\n  stop_command: pkill -f \"http.server 8000\"\n  working_dir: ./public\n</code></pre>"},{"location":"configuration/#health-checks","title":"Health Checks","text":"<p>Health checks monitor service status and determine when a service is \"healthy\".</p>"},{"location":"configuration/#heartbeat","title":"Heartbeat","text":"<p>Services actively report their health via SDK.</p> <p>Fields:</p> Field Type Required Description <code>type</code> <code>\"heartbeat\"</code> Yes Health check type <code>timeout</code> <code>string</code> Yes Max time between heartbeats (e.g., <code>2s</code>, <code>500ms</code>) <p>Example:</p> <pre><code>health_check:\n  type: heartbeat\n  timeout: 5s\n</code></pre> <p>SDK Usage:</p> <pre><code>from krill import KrillClient\n\nwith KrillClient(\"my-service\") as client:\n    while True:\n        # Do work...\n        client.heartbeat()\n        time.sleep(1)\n</code></pre>"},{"location":"configuration/#tcp","title":"TCP","text":"<p>Checks if a TCP port is open.</p> <p>Fields:</p> Field Type Required Description <code>type</code> <code>\"tcp\"</code> Yes Health check type <code>port</code> <code>integer</code> Yes TCP port (1-65535) <code>timeout</code> <code>string</code> No Connection timeout <p>Example:</p> <pre><code>health_check:\n  type: tcp\n  port: 8080\n  timeout: 2s\n</code></pre>"},{"location":"configuration/#http","title":"HTTP","text":"<p>Performs HTTP health checks.</p> <p>Fields:</p> Field Type Required Description <code>type</code> <code>\"http\"</code> Yes Health check type <code>port</code> <code>integer</code> Yes HTTP port (1-65535) <code>path</code> <code>string</code> No Endpoint path (default: <code>/health</code>) <code>expected_status</code> <code>integer</code> No Expected HTTP status (default: <code>200</code>) <p>Example:</p> <pre><code>health_check:\n  type: http\n  port: 8080\n  path: /api/health\n  expected_status: 200\n</code></pre>"},{"location":"configuration/#script","title":"Script","text":"<p>Runs a custom command to verify health.</p> <p>Fields:</p> Field Type Required Description <code>type</code> <code>\"script\"</code> Yes Health check type <code>command</code> <code>string</code> Yes Health check command (exit 0 = healthy) <code>timeout</code> <code>string</code> No Execution timeout <p>Example:</p> <pre><code>health_check:\n  type: script\n  command: curl -f http://localhost:8080/health\n  timeout: 3s\n</code></pre>"},{"location":"configuration/#policies","title":"Policies","text":"<p>Control restart behavior and timeouts.</p>"},{"location":"configuration/#policy-fields","title":"Policy Fields","text":"Field Type Default Description <code>restart</code> <code>\"never\"</code> | <code>\"always\"</code> | <code>\"on-failure\"</code> <code>\"never\"</code> When to restart <code>max_restarts</code> <code>integer</code> <code>0</code> Max restart attempts (0 = unlimited) <code>restart_delay</code> <code>string</code> <code>\"1s\"</code> Delay between restarts <code>stop_timeout</code> <code>string</code> <code>\"10s\"</code> Timeout before SIGKILL"},{"location":"configuration/#restart-policies","title":"Restart Policies","text":"<ul> <li><code>never</code>: Never restart the service automatically</li> <li><code>always</code>: Always restart, regardless of exit code</li> <li><code>on-failure</code>: Only restart if the service exits with non-zero code</li> </ul> <p>Example:</p> <pre><code>policy:\n  restart: on-failure\n  max_restarts: 3\n  restart_delay: 5s\n  stop_timeout: 30s\n</code></pre>"},{"location":"configuration/#dependencies","title":"Dependencies","text":"<p>Services can depend on other services with different conditions.</p>"},{"location":"configuration/#simple-dependency","title":"Simple Dependency","text":"<p>Wait for service to start (doesn't check health):</p> <pre><code>dependencies:\n  - lidar\n  - camera\n</code></pre>"},{"location":"configuration/#conditional-dependency","title":"Conditional Dependency","text":"<p>Wait for specific conditions:</p> <pre><code>dependencies:\n  - lidar: started   # Wait until started\n  - camera: healthy  # Wait until healthy\n</code></pre>"},{"location":"configuration/#dependency-conditions","title":"Dependency Conditions","text":"<ul> <li><code>started</code>: Service has been started (default)</li> <li><code>healthy</code>: Service is running AND health check passes</li> </ul> <p>Example:</p> <pre><code>services:\n  sensors:\n    execute:\n      type: ros2\n      package: sensor_drivers\n      launch_file: sensors.launch.py\n\n  processing:\n    execute:\n      type: pixi\n      task: run-processor\n    dependencies:\n      - sensors: healthy  # Wait for sensors to be healthy\n\n  visualization:\n    execute:\n      type: docker\n      image: viz:latest\n    dependencies:\n      - sensors: started   # Just wait for sensors to start\n      - processing: healthy # Wait for processing to be healthy\n</code></pre>"},{"location":"configuration/#duration-format","title":"Duration Format","text":"<p>Many fields accept duration strings with these units:</p> <ul> <li><code>ms</code> - milliseconds</li> <li><code>s</code> - seconds</li> <li><code>m</code> - minutes</li> <li><code>h</code> - hours</li> </ul> <p>Examples: - <code>500ms</code> - 500 milliseconds - <code>5s</code> - 5 seconds - <code>2m</code> - 2 minutes - <code>1h</code> - 1 hour</p>"},{"location":"configuration/#complete-example","title":"Complete Example","text":"<pre><code>version: \"1\"\nname: mobile-robot\nlog_dir: ~/.krill/logs\n\nenv:\n  ROS_DOMAIN_ID: \"42\"\n  LOG_LEVEL: \"info\"\n\nservices:\n  # Hardware layer\n  lidar:\n    execute:\n      type: ros2\n      package: ldlidar_ros2\n      launch_file: ldlidar.launch.py\n    health_check:\n      type: tcp\n      port: 4048\n    policy:\n      restart: on-failure\n      max_restarts: 3\n      restart_delay: 2s\n\n  # Perception layer\n  slam:\n    execute:\n      type: pixi\n      task: run-slam\n      environment: perception\n    dependencies:\n      - lidar: healthy\n    gpu: true\n    health_check:\n      type: heartbeat\n      timeout: 5s\n    policy:\n      restart: always\n\n  # Control layer\n  navigation:\n    execute:\n      type: ros2\n      package: nav2_bringup\n      launch_file: navigation_launch.py\n      launch_args:\n        use_sim_time: \"false\"\n    dependencies:\n      - slam: healthy\n    critical: true\n    health_check:\n      type: http\n      port: 8080\n      path: /health\n\n  # Monitoring\n  dashboard:\n    execute:\n      type: docker\n      image: grafana/grafana:latest\n      ports:\n        - \"3000:3000\"\n      volumes:\n        - \"./grafana-data:/var/lib/grafana\"\n      network: host\n    dependencies:\n      - navigation: started\n</code></pre>"},{"location":"dependencies/","title":"Dependencies and DAG Orchestration","text":"<p>Master service dependencies and build reliable orchestration graphs with Krill.</p>"},{"location":"dependencies/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Dependency Basics</li> <li>Dependency Conditions</li> <li>Startup Order</li> <li>Failure Handling</li> <li>Common Patterns</li> <li>Best Practices</li> </ul>"},{"location":"dependencies/#overview","title":"Overview","text":"<p>Krill uses a Directed Acyclic Graph (DAG) to orchestrate service startup, ensuring: - Services start in the correct order - Dependencies are satisfied before dependents start - Failures cascade appropriately to dependent services</p>"},{"location":"dependencies/#dependency-basics","title":"Dependency Basics","text":""},{"location":"dependencies/#simple-dependencies","title":"Simple Dependencies","text":"<p>The simplest form waits for a service to start:</p> <pre><code>services:\n  database:\n    execute:\n      type: docker\n      image: postgres:15\n\n  api:\n    execute:\n      type: pixi\n      task: start-api\n    dependencies:\n      - database  # Wait for database to start\n</code></pre>"},{"location":"dependencies/#multiple-dependencies","title":"Multiple Dependencies","text":"<p>Services can depend on multiple others:</p> <pre><code>services:\n  lidar:\n    execute:\n      type: ros2\n      package: ldlidar_ros2\n      launch_file: ldlidar.launch.py\n\n  camera:\n    execute:\n      type: ros2\n      package: realsense2_camera\n      launch_file: rs_launch.py\n\n  perception:\n    execute:\n      type: pixi\n      task: run-perception\n    dependencies:\n      - lidar\n      - camera  # Wait for both sensors\n</code></pre>"},{"location":"dependencies/#dependency-conditions","title":"Dependency Conditions","text":"<p>Control when a dependency is considered satisfied:</p>"},{"location":"dependencies/#started-default","title":"<code>started</code> (Default)","text":"<p>Dependency is satisfied when the service process has started:</p> <pre><code>dependencies:\n  - service-name  # Shorthand for \"started\"\n  - other-service: started  # Explicit\n</code></pre> <p>Use when: - Service doesn't need to be fully initialized - You just need the process running - Fast startup is more important than readiness</p>"},{"location":"dependencies/#healthy","title":"<code>healthy</code>","text":"<p>Dependency is satisfied when the service is healthy (requires health check):</p> <pre><code>dependencies:\n  - service-name: healthy\n</code></pre> <p>Use when: - Dependent needs service to be fully operational - Service exposes a health endpoint or port - Correctness is more important than speed</p> <p>Requirements: - Dependency must have a <code>health_check</code> configured - Health check must pass before dependent starts</p>"},{"location":"dependencies/#mixed-conditions","title":"Mixed Conditions","text":"<p>Combine different conditions for different dependencies:</p> <pre><code>services:\n  database:\n    execute:\n      type: docker\n      image: postgres:15\n    health_check:\n      type: tcp\n      port: 5432\n\n  cache:\n    execute:\n      type: docker\n      image: redis:7\n    health_check:\n      type: tcp\n      port: 6379\n\n  worker:\n    execute:\n      type: shell\n      command: python worker.py\n\n  api:\n    execute:\n      type: pixi\n      task: start-api\n    dependencies:\n      - database: healthy  # Must be ready for queries\n      - cache: healthy     # Must be ready for caching\n      - worker: started    # Just needs to be running\n</code></pre>"},{"location":"dependencies/#startup-order","title":"Startup Order","text":""},{"location":"dependencies/#linear-chain","title":"Linear Chain","text":"<p>Services start sequentially:</p> <pre><code>services:\n  step1:\n    execute:\n      type: shell\n      command: ./init.sh\n\n  step2:\n    execute:\n      type: pixi\n      task: setup\n    dependencies:\n      - step1\n\n  step3:\n    execute:\n      type: docker\n      image: app:latest\n    dependencies:\n      - step2\n</code></pre> <p>Startup: step1 \u2192 step2 \u2192 step3</p>"},{"location":"dependencies/#parallel-branches","title":"Parallel Branches","text":"<p>Independent services start in parallel:</p> <pre><code>services:\n  # These start in parallel\n  sensor-a:\n    execute:\n      type: ros2\n      package: sensor_a\n      launch_file: sensor.launch.py\n\n  sensor-b:\n    execute:\n      type: ros2\n      package: sensor_b\n      launch_file: sensor.launch.py\n\n  # This waits for both\n  fusion:\n    execute:\n      type: pixi\n      task: sensor-fusion\n    dependencies:\n      - sensor-a: healthy\n      - sensor-b: healthy\n</code></pre> <p>Startup: sensor-a and sensor-b start together \u2192 fusion starts when both are healthy</p>"},{"location":"dependencies/#diamond-pattern","title":"Diamond Pattern","text":"<p>Multiple paths converge:</p> <pre><code>services:\n  config:\n    execute:\n      type: shell\n      command: ./load-config.sh\n\n  service-a:\n    execute:\n      type: pixi\n      task: start-a\n    dependencies:\n      - config\n\n  service-b:\n    execute:\n      type: pixi\n      task: start-b\n    dependencies:\n      - config\n\n  aggregator:\n    execute:\n      type: docker\n      image: aggregator:latest\n    dependencies:\n      - service-a: healthy\n      - service-b: healthy\n</code></pre> <p>Startup: config \u2192 (service-a and service-b in parallel) \u2192 aggregator</p>"},{"location":"dependencies/#layered-architecture","title":"Layered Architecture","text":"<p>Build complex dependency graphs:</p> <pre><code>services:\n  # Layer 1: Hardware\n  lidar:\n    execute:\n      type: ros2\n      package: ldlidar_ros2\n      launch_file: ldlidar.launch.py\n    health_check:\n      type: tcp\n      port: 4048\n\n  camera:\n    execute:\n      type: ros2\n      package: realsense2_camera\n      launch_file: rs_launch.py\n    health_check:\n      type: tcp\n      port: 8554\n\n  # Layer 2: Perception\n  slam:\n    execute:\n      type: pixi\n      task: run-slam\n    dependencies:\n      - lidar: healthy\n      - camera: healthy\n    health_check:\n      type: heartbeat\n      timeout: 5s\n\n  object-detection:\n    execute:\n      type: docker\n      image: detection:latest\n    dependencies:\n      - camera: healthy\n    health_check:\n      type: http\n      port: 8080\n\n  # Layer 3: Planning\n  path-planner:\n    execute:\n      type: ros2\n      package: nav2_bringup\n      launch_file: navigation_launch.py\n    dependencies:\n      - slam: healthy\n      - object-detection: healthy\n    health_check:\n      type: tcp\n      port: 9090\n\n  # Layer 4: Control\n  controller:\n    execute:\n      type: pixi\n      task: run-controller\n    dependencies:\n      - path-planner: healthy\n    critical: true\n</code></pre>"},{"location":"dependencies/#failure-handling","title":"Failure Handling","text":""},{"location":"dependencies/#cascading-failures","title":"Cascading Failures","text":"<p>When a service fails, Krill automatically stops all dependent services:</p> <pre><code>services:\n  database:\n    execute:\n      type: docker\n      image: postgres:15\n\n  api:\n    dependencies:\n      - database\n    # If database fails, api is automatically stopped\n</code></pre> <p>Behavior: 1. Database fails 2. Krill detects failure 3. API is stopped (cascade) 4. System settles into a safe state</p>"},{"location":"dependencies/#critical-services","title":"Critical Services","text":"<p>Mark services as critical to trigger emergency stop:</p> <pre><code>services:\n  safety-monitor:\n    execute:\n      type: pixi\n      task: safety-check\n    critical: true  # Failure stops ALL services\n    health_check:\n      type: heartbeat\n      timeout: 1s\n\n  motor-controller:\n    dependencies:\n      - safety-monitor: healthy\n</code></pre> <p>Behavior: 1. Safety-monitor fails 2. Krill triggers emergency stop 3. ALL services are stopped immediately 4. System enters safe state</p>"},{"location":"dependencies/#restart-policies","title":"Restart Policies","text":"<p>Control how failures affect the dependency graph:</p> <pre><code>services:\n  flaky-sensor:\n    execute:\n      type: shell\n      command: ./sensor-reader\n    policy:\n      restart: on-failure\n      max_restarts: 3\n      restart_delay: 2s\n    health_check:\n      type: tcp\n      port: 5000\n\n  processor:\n    dependencies:\n      - flaky-sensor: healthy\n    # Waits for sensor to restart and become healthy\n</code></pre>"},{"location":"dependencies/#common-patterns","title":"Common Patterns","text":""},{"location":"dependencies/#database-backed-application","title":"Database-Backed Application","text":"<pre><code>services:\n  postgres:\n    execute:\n      type: docker\n      image: postgres:15\n      volumes:\n        - \"./data:/var/lib/postgresql/data\"\n    health_check:\n      type: tcp\n      port: 5432\n    policy:\n      restart: on-failure\n\n  migrations:\n    execute:\n      type: shell\n      command: alembic upgrade head\n    dependencies:\n      - postgres: healthy\n    # Runs once, exits when done\n\n  backend:\n    execute:\n      type: pixi\n      task: start-backend\n    dependencies:\n      - migrations  # Wait for migrations to complete\n    health_check:\n      type: http\n      port: 8000\n      path: /health\n    policy:\n      restart: always\n</code></pre>"},{"location":"dependencies/#ros2-robot-stack","title":"ROS2 Robot Stack","text":"<pre><code>services:\n  # Hardware drivers\n  motors:\n    execute:\n      type: ros2\n      package: motor_driver\n      launch_file: motors.launch.py\n    health_check:\n      type: tcp\n      port: 7000\n\n  sensors:\n    execute:\n      type: ros2\n      package: sensor_suite\n      launch_file: sensors.launch.py\n    health_check:\n      type: tcp\n      port: 7001\n\n  # Middle layer\n  localization:\n    execute:\n      type: ros2\n      package: robot_localization\n      launch_file: ekf.launch.py\n    dependencies:\n      - motors: healthy\n      - sensors: healthy\n\n  # High level\n  navigation:\n    execute:\n      type: ros2\n      package: nav2_bringup\n      launch_file: navigation_launch.py\n    dependencies:\n      - localization: started\n    critical: true\n</code></pre>"},{"location":"dependencies/#microservices-with-monitoring","title":"Microservices with Monitoring","text":"<pre><code>services:\n  # Infrastructure\n  prometheus:\n    execute:\n      type: docker\n      image: prom/prometheus:latest\n      ports:\n        - \"9090:9090\"\n    health_check:\n      type: http\n      port: 9090\n\n  # Services\n  auth-service:\n    execute:\n      type: docker\n      image: auth:v1\n    health_check:\n      type: http\n      port: 8001\n      path: /health\n\n  user-service:\n    execute:\n      type: docker\n      image: users:v1\n    dependencies:\n      - auth-service: healthy\n    health_check:\n      type: http\n      port: 8002\n\n  api-gateway:\n    execute:\n      type: docker\n      image: gateway:v1\n      ports:\n        - \"80:80\"\n    dependencies:\n      - auth-service: healthy\n      - user-service: healthy\n    health_check:\n      type: http\n      port: 80\n\n  # Monitoring depends on all services starting\n  grafana:\n    execute:\n      type: docker\n      image: grafana/grafana:latest\n      ports:\n        - \"3000:3000\"\n    dependencies:\n      - prometheus: started\n      - api-gateway: started\n</code></pre>"},{"location":"dependencies/#development-environment","title":"Development Environment","text":"<pre><code>services:\n  # Start database first\n  dev-db:\n    execute:\n      type: docker\n      image: postgres:15\n      ports:\n        - \"5432:5432\"\n    health_check:\n      type: tcp\n      port: 5432\n\n  # Run migrations\n  dev-migrate:\n    execute:\n      type: shell\n      command: npm run migrate\n    dependencies:\n      - dev-db: healthy\n\n  # Start backend with hot reload\n  dev-backend:\n    execute:\n      type: shell\n      command: npm run dev\n      working_dir: ./backend\n    dependencies:\n      - dev-migrate\n    health_check:\n      type: http\n      port: 3001\n    policy:\n      restart: on-failure\n\n  # Start frontend with hot reload\n  dev-frontend:\n    execute:\n      type: shell\n      command: npm run dev\n      working_dir: ./frontend\n    dependencies:\n      - dev-backend: started\n    health_check:\n      type: http\n      port: 3000\n</code></pre>"},{"location":"dependencies/#best-practices","title":"Best Practices","text":""},{"location":"dependencies/#1-use-health-checks-for-readiness","title":"1. Use Health Checks for Readiness","text":"<p>Always use <code>healthy</code> dependencies when the dependent truly needs the service ready:</p> <pre><code># \u274c Bad: API starts before DB is ready\napi:\n  dependencies:\n    - database  # Just \"started\", might not be ready\n\n# \u2705 Good: API waits for DB to be ready\napi:\n  dependencies:\n    - database: healthy\n</code></pre>"},{"location":"dependencies/#2-minimize-dependency-chains","title":"2. Minimize Dependency Chains","text":"<p>Shorter chains start faster and are easier to debug:</p> <pre><code># \u274c Bad: Long sequential chain\na: {}\nb:\n  dependencies: [a]\nc:\n  dependencies: [b]\nd:\n  dependencies: [c]\n\n# \u2705 Good: Parallel where possible\na: {}\nb: {}\nc: {}\nd:\n  dependencies: [a, b, c]\n</code></pre>"},{"location":"dependencies/#3-use-critical-flag-sparingly","title":"3. Use Critical Flag Sparingly","text":"<p>Reserve <code>critical</code> for truly safety-critical services:</p> <pre><code># \u2705 Good: Critical for safety\nemergency-stop:\n  critical: true\n\n# \u274c Bad: Dashboard isn't safety-critical\ndashboard:\n  critical: true  # Don't stop everything if dashboard fails\n</code></pre>"},{"location":"dependencies/#4-layer-your-architecture","title":"4. Layer Your Architecture","text":"<p>Group services into logical layers:</p> <pre><code># Layer 1: Infrastructure\n# Layer 2: Data/Storage\n# Layer 3: Business Logic\n# Layer 4: API/Interface\n</code></pre>"},{"location":"dependencies/#5-handle-circular-dependencies","title":"5. Handle Circular Dependencies","text":"<p>Krill rejects circular dependencies. If you encounter this:</p> <pre><code># \u274c This will fail\nservice-a:\n  dependencies: [service-b]\nservice-b:\n  dependencies: [service-a]\n</code></pre> <p>Solutions: - Redesign to remove circular dependency - Split into smaller services - Use message queues for loose coupling</p>"},{"location":"dependencies/#6-test-failure-scenarios","title":"6. Test Failure Scenarios","text":"<p>Verify your dependency graph handles failures correctly:</p> <pre><code># Start system\nkrill up recipe.yaml\n\n# Kill a service and observe cascades\nkrill service stop service-name\n\n# Check dependent services stopped correctly\n</code></pre>"},{"location":"dependencies/#troubleshooting","title":"Troubleshooting","text":""},{"location":"dependencies/#services-start-out-of-order","title":"Services Start Out of Order","text":"<p>Check: - Dependencies are correctly specified - Health checks are configured for <code>healthy</code> dependencies - No typos in service names</p>"},{"location":"dependencies/#circular-dependency-error","title":"Circular Dependency Error","text":"<p>Solution: - Review your dependency graph - Look for cycles (A \u2192 B \u2192 C \u2192 A) - Redesign to break the cycle</p>"},{"location":"dependencies/#service-waits-forever","title":"Service Waits Forever","text":"<p>Possible causes: 1. Dependency never becomes healthy 2. Dependency health check is misconfigured 3. Dependency service is failing</p> <p>Debug: <pre><code># View service status\nkrill tui\n\n# Check logs\nkrill logs dependency-name\n</code></pre></p>"},{"location":"dependencies/#cascading-failures-too-aggressive","title":"Cascading Failures Too Aggressive","text":"<p>Solution: - Review critical flags - Consider using restart policies - May need to restructure dependencies</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust toolchain installed</li> <li>Just task runner installed</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>git clone https://github.com/Zero-Robotics/krill.git\ncd krill\njust install\n</code></pre> <p>This builds and installs the <code>krill</code> binary to your Cargo bin directory.</p>"},{"location":"getting-started/#your-first-recipe","title":"Your First Recipe","text":"<p>Create a file called <code>krill.yaml</code>:</p> <pre><code>version: \"1\"\nname: my-first-recipe\n\nservices:\n  hello:\n    execute:\n      type: shell\n      command: bash -c 'while true; do echo \"Hello from Krill!\"; sleep 2; done'\n    policy:\n      restart: always\n</code></pre>"},{"location":"getting-started/#start-it","title":"Start It","text":"<pre><code>krill up krill.yaml\n</code></pre> <p>This starts the daemon and opens the TUI where you can monitor your services in real time.</p>"},{"location":"getting-started/#tui-controls","title":"TUI Controls","text":"Key Action <code>\u2191</code>/<code>\u2193</code> Navigate services <code>Enter</code> View service logs <code>d</code> Service detail view <code>r</code> Restart service <code>s</code> Stop service <code>q</code> Quit TUI"},{"location":"getting-started/#stop-everything","title":"Stop Everything","text":"<p>Press <code>q</code> in the TUI, or from another terminal:</p> <pre><code>krill down\n</code></pre>"},{"location":"getting-started/#detached-mode","title":"Detached Mode","text":"<p>Start without the TUI:</p> <pre><code>krill up krill.yaml -d\n</code></pre> <p>Attach later with:</p> <pre><code>krill ps\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Browse the Examples to see real-world recipes</li> <li>Read the Configuration Reference for all options</li> <li>Check the Quick Reference for a cheat sheet</li> </ul>"},{"location":"health-checks/","title":"Health Checks Guide","text":"<p>Learn how to effectively monitor your services with Krill's health check system.</p>"},{"location":"health-checks/#overview","title":"Overview","text":"<p>Health checks allow Krill to: - Monitor service health continuously - Determine when dependencies are satisfied (<code>healthy</code> condition) - Trigger restarts on health failures (with <code>on-failure</code> policy) - Report accurate service status in the TUI</p>"},{"location":"health-checks/#health-check-types","title":"Health Check Types","text":""},{"location":"health-checks/#heartbeat","title":"Heartbeat","text":"<p>Best for: Custom services where you control the code</p> <p>Services actively report they're alive using Krill SDKs.</p> <pre><code>health_check:\n  type: heartbeat\n  timeout: 5s\n</code></pre> <p>How it works: 1. Service must send heartbeats within the timeout period 2. If timeout expires without a heartbeat, service is marked unhealthy 3. Heartbeats can be sent from Rust, Python, or C++ using Krill SDKs</p> <p>Rust Example:</p> <pre><code>use krill_sdk_rust::KrillClient;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let client = KrillClient::new(\"my-service\").await?;\n\n    loop {\n        // Do work...\n        process_data().await?;\n\n        // Report health\n        client.heartbeat().await?;\n\n        tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;\n    }\n}\n</code></pre> <p>Python Example:</p> <pre><code>from krill import KrillClient\nimport time\n\nwith KrillClient(\"my-service\") as client:\n    while True:\n        # Do work...\n        process_data()\n\n        # Report health\n        client.heartbeat()\n\n        time.sleep(2)\n</code></pre> <p>Python Async Example:</p> <pre><code>import asyncio\nfrom krill import AsyncKrillClient\n\nasync def main():\n    client = await AsyncKrillClient.connect(\"my-service\")\n\n    while True:\n        # Do work...\n        await process_data()\n\n        # Report health\n        await client.heartbeat()\n\n        await asyncio.sleep(2)\n\nasyncio.run(main())\n</code></pre> <p>C++ Example:</p> <pre><code>#include \"krill.hpp\"\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n\nint main() {\n    try {\n        krill::Client client(\"my-service\");\n\n        while (true) {\n            // Do work...\n            process_data();\n\n            // Report health\n            client.heartbeat();\n\n            std::this_thread::sleep_for(std::chrono::seconds(2));\n        }\n    } catch (const krill::KrillError&amp; e) {\n        std::cerr &lt;&lt; \"Error: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n        return 1;\n    }\n}\n</code></pre> <p>Best Practices: - Set timeout 2-3x your heartbeat interval for safety margin - Send heartbeats from your main processing loop - Don't send heartbeats if your service is degraded</p>"},{"location":"health-checks/#tcp","title":"TCP","text":"<p>Best for: Services that expose a TCP port</p> <p>Checks if a TCP port accepts connections.</p> <pre><code>health_check:\n  type: tcp\n  port: 8080\n  timeout: 2s\n</code></pre> <p>How it works: 1. Krill attempts to establish a TCP connection to <code>localhost:port</code> 2. If connection succeeds, service is healthy 3. If connection fails or times out, service is unhealthy</p> <p>Use Cases: - Databases (PostgreSQL, Redis) - Message brokers (RabbitMQ, Kafka) - Any service listening on a TCP port</p> <p>Example:</p> <pre><code>services:\n  redis:\n    execute:\n      type: shell\n      command: redis-server\n    health_check:\n      type: tcp\n      port: 6379\n      timeout: 1s\n</code></pre>"},{"location":"health-checks/#http","title":"HTTP","text":"<p>Best for: Web services and REST APIs</p> <p>Performs HTTP GET requests to a health endpoint.</p> <pre><code>health_check:\n  type: http\n  port: 8080\n  path: /health\n  expected_status: 200\n</code></pre> <p>How it works: 1. Krill sends <code>GET http://localhost:port/path</code> 2. If response status matches <code>expected_status</code>, service is healthy 3. Otherwise, service is unhealthy</p> <p>Implementing a Health Endpoint:</p> <pre><code># FastAPI example\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/health\")\nasync def health_check():\n    # Add your health logic here\n    if database.is_connected() and cache.is_available():\n        return {\"status\": \"healthy\"}\n    else:\n        return {\"status\": \"unhealthy\"}, 503\n</code></pre> <p>Example:</p> <pre><code>services:\n  api-server:\n    execute:\n      type: pixi\n      task: start-api\n    health_check:\n      type: http\n      port: 8080\n      path: /api/health\n      expected_status: 200\n</code></pre>"},{"location":"health-checks/#script","title":"Script","text":"<p>Best for: Custom health logic that doesn't fit other types</p> <p>Runs a shell command to determine health.</p> <pre><code>health_check:\n  type: script\n  command: curl -f http://localhost:8080/health\n  timeout: 3s\n</code></pre> <p>How it works: 1. Krill executes the command 2. Exit code 0 = healthy 3. Non-zero exit code = unhealthy</p> <p>Use Cases: - Complex health checks requiring multiple conditions - Checking file existence or content - Custom validation logic</p> <p>Examples:</p> <pre><code># Check if service responds AND database is accessible\nhealth_check:\n  type: script\n  command: curl -f http://localhost:8080/health &amp;&amp; pg_isready -h localhost\n  timeout: 5s\n</code></pre> <pre><code># Check if a file exists and was modified recently\nhealth_check:\n  type: script\n  command: test -f /var/run/service.pid &amp;&amp; find /var/run/service.pid -mmin -1\n  timeout: 1s\n</code></pre>"},{"location":"health-checks/#choosing-the-right-health-check","title":"Choosing the Right Health Check","text":"Service Type Recommended Check Reason Custom application (you control code) Heartbeat Most accurate, reports actual internal state ROS2 nodes TCP or Heartbeat ROS2 nodes often expose ports; heartbeat for custom nodes Web APIs HTTP Native support for health endpoints Databases TCP Simple connection test Docker containers TCP or HTTP Depends on what container exposes Shell scripts Script Custom validation logic"},{"location":"health-checks/#health-check-strategies","title":"Health Check Strategies","text":""},{"location":"health-checks/#fast-startup-detection","title":"Fast Startup Detection","text":"<p>Use TCP/HTTP checks for services that expose ports immediately:</p> <pre><code>services:\n  nginx:\n    execute:\n      type: docker\n      image: nginx:latest\n      ports:\n        - \"80:80\"\n    health_check:\n      type: http\n      port: 80\n      path: /\n      expected_status: 200\n</code></pre>"},{"location":"health-checks/#accurate-state-monitoring","title":"Accurate State Monitoring","text":"<p>Use heartbeat for services where you need to know internal state:</p> <pre><code>services:\n  data-processor:\n    execute:\n      type: pixi\n      task: run-processor\n    health_check:\n      type: heartbeat\n      timeout: 10s\n</code></pre> <p>In your code:</p> <pre><code>with KrillClient(\"data-processor\") as client:\n    while True:\n        try:\n            data = queue.get(timeout=5)\n            process(data)\n            client.heartbeat()  # Only heartbeat when actually processing\n        except QueueEmpty:\n            # Don't heartbeat when idle - this will mark as unhealthy\n            pass\n</code></pre>"},{"location":"health-checks/#multi-layer-checks","title":"Multi-Layer Checks","text":"<p>Combine different checks for different services:</p> <pre><code>services:\n  # Hardware: TCP check for quick startup detection\n  lidar:\n    execute:\n      type: ros2\n      package: ldlidar_ros2\n      launch_file: ldlidar.launch.py\n    health_check:\n      type: tcp\n      port: 4048\n\n  # Processing: Heartbeat for accurate state\n  slam:\n    execute:\n      type: pixi\n      task: run-slam\n    dependencies:\n      - lidar: healthy\n    health_check:\n      type: heartbeat\n      timeout: 5s\n\n  # API: HTTP for standard health endpoint\n  api:\n    execute:\n      type: docker\n      image: api-server:latest\n    dependencies:\n      - slam: healthy\n    health_check:\n      type: http\n      port: 8080\n      path: /health\n</code></pre>"},{"location":"health-checks/#health-check-timing","title":"Health Check Timing","text":""},{"location":"health-checks/#startup-phase","title":"Startup Phase","text":"<ul> <li>Services start as <code>starting</code></li> <li>First successful health check \u2192 <code>healthy</code></li> <li>Failed health checks don't trigger restarts during initial startup</li> </ul>"},{"location":"health-checks/#running-phase","title":"Running Phase","text":"<ul> <li>Continuous health monitoring</li> <li>Health failures can trigger <code>on-failure</code> restarts</li> <li><code>healthy</code> dependencies wait for health checks to pass</li> </ul>"},{"location":"health-checks/#shutdown-phase","title":"Shutdown Phase","text":"<ul> <li>Health checks stop when service is stopping</li> <li>No false negatives during graceful shutdown</li> </ul>"},{"location":"health-checks/#common-patterns","title":"Common Patterns","text":""},{"location":"health-checks/#critical-services-with-monitoring","title":"Critical Services with Monitoring","text":"<pre><code>services:\n  motion-controller:\n    execute:\n      type: ros2\n      package: motion_control\n      launch_file: controller.launch.py\n    critical: true  # Emergency stop if this fails\n    health_check:\n      type: heartbeat\n      timeout: 2s  # Short timeout for safety-critical\n    policy:\n      restart: on-failure\n      max_restarts: 1  # Don't retry infinitely\n</code></pre>"},{"location":"health-checks/#dependent-startup-chain","title":"Dependent Startup Chain","text":"<pre><code>services:\n  database:\n    execute:\n      type: docker\n      image: postgres:15\n    health_check:\n      type: tcp\n      port: 5432\n\n  backend:\n    execute:\n      type: pixi\n      task: start-backend\n    dependencies:\n      - database: healthy  # Wait for DB to be ready\n    health_check:\n      type: http\n      port: 8000\n      path: /health\n\n  frontend:\n    execute:\n      type: docker\n      image: frontend:latest\n    dependencies:\n      - backend: healthy  # Wait for backend to be ready\n    health_check:\n      type: http\n      port: 3000\n</code></pre>"},{"location":"health-checks/#resilient-services","title":"Resilient Services","text":"<pre><code>services:\n  sensor-reader:\n    execute:\n      type: pixi\n      task: read-sensors\n    health_check:\n      type: heartbeat\n      timeout: 10s  # Allow some processing time\n    policy:\n      restart: always  # Always restart on failure\n      max_restarts: 0  # Unlimited retries\n      restart_delay: 5s  # Wait before retry\n</code></pre>"},{"location":"health-checks/#troubleshooting","title":"Troubleshooting","text":""},{"location":"health-checks/#service-never-becomes-healthy","title":"Service Never Becomes Healthy","text":"<p>TCP/HTTP checks: - Verify the service is actually listening on the specified port - Check firewall rules - Ensure <code>localhost</code> resolves correctly</p> <p>Heartbeat checks: - Verify SDK is correctly initialized - Check that heartbeats are being sent - Review timeout duration vs heartbeat frequency</p> <p>Script checks: - Run the command manually to verify it works - Check command output and exit codes - Verify timeouts are sufficient</p>"},{"location":"health-checks/#intermittent-health-failures","title":"Intermittent Health Failures","text":"<p>Symptoms: Service flaps between healthy and unhealthy</p> <p>Solutions: - Increase health check timeout - Reduce heartbeat frequency vs timeout ratio - Check for resource contention (CPU, memory) - Review service logs for errors</p>"},{"location":"health-checks/#dependencies-never-satisfied","title":"Dependencies Never Satisfied","text":"<p>Symptoms: Service waits forever for dependency</p> <p>Solutions: - Check that dependency has a health check configured - Verify dependency service is starting successfully - Review dependency health check configuration - Check dependency service logs</p>"},{"location":"quick-reference/","title":"Quick Reference","text":"<p>Fast lookup for common Krill configurations.</p>"},{"location":"quick-reference/#minimal-recipe","title":"Minimal Recipe","text":"<pre><code>version: \"1\"\nname: my-project\n\nservices:\n  my-service:\n    execute:\n      type: shell\n      command: python server.py\n</code></pre>"},{"location":"quick-reference/#execute-types","title":"Execute Types","text":""},{"location":"quick-reference/#pixi","title":"Pixi","text":"<pre><code>execute:\n  type: pixi\n  task: start-server\n  environment: production  # optional\n  working_dir: ./services  # optional\n  stop_task: cleanup       # optional\n</code></pre>"},{"location":"quick-reference/#ros2","title":"ROS2","text":"<pre><code>execute:\n  type: ros2\n  package: nav2_bringup\n  launch_file: navigation_launch.py\n  launch_args:              # optional\n    use_sim_time: \"false\"\n    map: \"/maps/map.yaml\"\n  working_dir: ./ros2_ws    # optional\n</code></pre>"},{"location":"quick-reference/#docker","title":"Docker","text":"<pre><code>execute:\n  type: docker\n  image: nginx:latest\n  volumes:                  # optional\n    - \"/host:/container\"\n    - \"/data:/app:ro\"\n  ports:                    # optional\n    - \"8080:80\"\n    - \"443:443\"\n  privileged: false         # optional\n  network: bridge           # optional\n</code></pre>"},{"location":"quick-reference/#shell","title":"Shell","text":"<pre><code>execute:\n  type: shell\n  command: npm start\n  working_dir: ./app        # optional\n  stop_command: npm stop    # optional\n</code></pre>"},{"location":"quick-reference/#health-checks","title":"Health Checks","text":""},{"location":"quick-reference/#heartbeat","title":"Heartbeat","text":"<pre><code>health_check:\n  type: heartbeat\n  timeout: 5s\n</code></pre>"},{"location":"quick-reference/#tcp","title":"TCP","text":"<pre><code>health_check:\n  type: tcp\n  port: 8080\n  timeout: 2s  # optional\n</code></pre>"},{"location":"quick-reference/#http","title":"HTTP","text":"<pre><code>health_check:\n  type: http\n  port: 8080\n  path: /health              # optional, default: /health\n  expected_status: 200       # optional, default: 200\n</code></pre>"},{"location":"quick-reference/#script","title":"Script","text":"<pre><code>health_check:\n  type: script\n  command: curl -f localhost:8080/health\n  timeout: 3s  # optional\n</code></pre>"},{"location":"quick-reference/#dependencies","title":"Dependencies","text":""},{"location":"quick-reference/#simple-wait-for-start","title":"Simple (wait for start)","text":"<pre><code>dependencies:\n  - service-a\n  - service-b\n</code></pre>"},{"location":"quick-reference/#conditional-wait-for-healthy","title":"Conditional (wait for healthy)","text":"<pre><code>dependencies:\n  - service-a: started\n  - service-b: healthy\n</code></pre>"},{"location":"quick-reference/#policies","title":"Policies","text":""},{"location":"quick-reference/#never-restart","title":"Never Restart","text":"<pre><code>policy:\n  restart: never\n</code></pre>"},{"location":"quick-reference/#always-restart","title":"Always Restart","text":"<pre><code>policy:\n  restart: always\n  max_restarts: 0      # unlimited\n  restart_delay: 1s\n  stop_timeout: 10s\n</code></pre>"},{"location":"quick-reference/#restart-on-failure","title":"Restart on Failure","text":"<pre><code>policy:\n  restart: on-failure\n  max_restarts: 3\n  restart_delay: 5s\n  stop_timeout: 30s\n</code></pre>"},{"location":"quick-reference/#common-flags","title":"Common Flags","text":""},{"location":"quick-reference/#critical-service","title":"Critical Service","text":"<pre><code>services:\n  safety-monitor:\n    critical: true  # Emergency stop on failure\n    # ...\n</code></pre>"},{"location":"quick-reference/#gpu-required","title":"GPU Required","text":"<pre><code>services:\n  ml-inference:\n    gpu: true  # Validate GPU before starting\n    # ...\n</code></pre>"},{"location":"quick-reference/#complete-examples","title":"Complete Examples","text":""},{"location":"quick-reference/#simple-web-app","title":"Simple Web App","text":"<pre><code>version: \"1\"\nname: webapp\n\nservices:\n  backend:\n    execute:\n      type: docker\n      image: api:latest\n      ports:\n        - \"8000:8000\"\n    health_check:\n      type: http\n      port: 8000\n      path: /health\n    policy:\n      restart: always\n</code></pre>"},{"location":"quick-reference/#ros2-robot","title":"ROS2 Robot","text":"<pre><code>version: \"1\"\nname: robot\n\nenv:\n  ROS_DOMAIN_ID: \"42\"\n\nservices:\n  lidar:\n    execute:\n      type: ros2\n      package: ldlidar_ros2\n      launch_file: ldlidar.launch.py\n    health_check:\n      type: tcp\n      port: 4048\n\n  navigation:\n    execute:\n      type: ros2\n      package: nav2_bringup\n      launch_file: navigation_launch.py\n    dependencies:\n      - lidar: healthy\n    critical: true\n</code></pre>"},{"location":"quick-reference/#microservices","title":"Microservices","text":"<pre><code>version: \"1\"\nname: microservices\n\nservices:\n  database:\n    execute:\n      type: docker\n      image: postgres:15\n    health_check:\n      type: tcp\n      port: 5432\n\n  backend:\n    execute:\n      type: pixi\n      task: start\n    dependencies:\n      - database: healthy\n    health_check:\n      type: http\n      port: 8000\n\n  frontend:\n    execute:\n      type: docker\n      image: frontend:latest\n      ports:\n        - \"3000:3000\"\n    dependencies:\n      - backend: healthy\n</code></pre>"},{"location":"quick-reference/#duration-format","title":"Duration Format","text":"Unit Example Description <code>ms</code> <code>500ms</code> Milliseconds <code>s</code> <code>5s</code> Seconds <code>m</code> <code>2m</code> Minutes <code>h</code> <code>1h</code> Hours"},{"location":"quick-reference/#cli-commands","title":"CLI Commands","text":"<pre><code># Start daemon and open TUI\nkrill up recipe.yaml\n\n# Start daemon only (no TUI)\nkrill up recipe.yaml -d\n\n# Connect to running daemon\nkrill\n\n# Stop all services and daemon\nkrill down\n\n# View logs\nkrill logs service-name\n\n# Restart service\nkrill restart service-name\n\n# Stop service\nkrill stop service-name\n</code></pre>"},{"location":"quick-reference/#tui-keybindings","title":"TUI Keybindings","text":"Key Action <code>\u2191</code>/<code>k</code> Previous service <code>\u2193</code>/<code>j</code> Next service <code>Enter</code> View logs <code>d</code> Detail view <code>r</code> Restart service <code>s</code> Stop service <code>S</code> Stop daemon <code>q</code> Quit TUI <code>h</code> Help"},{"location":"quick-reference/#validation-rules","title":"Validation Rules","text":""},{"location":"quick-reference/#service-names","title":"Service Names","text":"<ul> <li>Only alphanumeric, hyphens, underscores</li> <li>Cannot be empty</li> <li>Examples: <code>my-service</code>, <code>camera_0</code>, <code>lidar1</code></li> </ul>"},{"location":"quick-reference/#shell-commands","title":"Shell Commands","text":"<p>Rejected patterns: - Pipes: <code>|</code> - Redirections: <code>&gt;</code>, <code>&lt;</code>, <code>&gt;&gt;</code> - Command substitution: <code>`</code>, <code>$()</code> - Background: <code>&amp;</code> - Command chaining: <code>;</code>, <code>&amp;&amp;</code>, <code>||</code></p> <p>Safe commands: <pre><code>command: python server.py           # \u2705\ncommand: node app.js --port 3000   # \u2705\ncommand: ls | grep foo             # \u274c\ncommand: echo \"hi\" &gt; output.txt    # \u274c\n</code></pre></p>"},{"location":"sdk-installation/","title":"SDK Installation and Usage Guide","text":"<p>Learn how to install and use Krill SDKs in your services for health monitoring via heartbeats.</p>"},{"location":"sdk-installation/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Python SDK</li> <li>Rust SDK</li> <li>C++ SDK</li> <li>When to Use SDKs</li> <li>Examples</li> </ul>"},{"location":"sdk-installation/#overview","title":"Overview","text":"<p>Krill SDKs allow your services to report their health status via heartbeat health checks. This is the most accurate health monitoring method because your code explicitly signals when it's healthy.</p> <p>Key Concepts: - Services send periodic heartbeats to the Krill daemon - If heartbeats stop, the service is marked unhealthy - Works over Unix domain sockets (IPC) - Zero-copy, lightweight communication</p>"},{"location":"sdk-installation/#python-sdk","title":"Python SDK","text":""},{"location":"sdk-installation/#installation","title":"Installation","text":"<p>Option 1: Install from source (recommended)</p> <pre><code>cd krill/sdk/krill-python\npip install .\n</code></pre> <p>Option 2: Install in development mode</p> <pre><code>cd krill/sdk/krill-python\npip install -e .\n</code></pre> <p>Option 3: Copy to your project</p> <pre><code># Just copy the single file\ncp krill/sdk/krill-python/krill.py your-project/\n</code></pre>"},{"location":"sdk-installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.7 or later</li> <li>No external dependencies (uses only stdlib)</li> <li>Unix-like system (Linux, macOS)</li> </ul>"},{"location":"sdk-installation/#basic-usage","title":"Basic Usage","text":"<pre><code>from krill import KrillClient\nimport time\n\n# Context manager (recommended)\nwith KrillClient(\"my-service\") as client:\n    while True:\n        # Do your work\n        process_data()\n\n        # Send heartbeat\n        client.heartbeat()\n\n        time.sleep(1)\n</code></pre>"},{"location":"sdk-installation/#async-usage","title":"Async Usage","text":"<pre><code>import asyncio\nfrom krill import AsyncKrillClient\n\nasync def main():\n    async with await AsyncKrillClient.connect(\"my-service\") as client:\n        while True:\n            # Do async work\n            await process_data()\n\n            # Send heartbeat\n            await client.heartbeat()\n\n            await asyncio.sleep(1)\n\nasyncio.run(main())\n</code></pre>"},{"location":"sdk-installation/#configuration-in-recipe","title":"Configuration in Recipe","text":"<pre><code>services:\n  my-service:\n    execute:\n      type: pixi\n      task: run-service\n    health_check:\n      type: heartbeat\n      timeout: 5s  # Must send heartbeat every 5s\n</code></pre>"},{"location":"sdk-installation/#complete-example","title":"Complete Example","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"Example service with Krill heartbeat monitoring.\"\"\"\n\nfrom krill import KrillClient, ConnectionError, SendError\nimport time\nimport sys\n\ndef process_frame():\n    \"\"\"Simulate some work.\"\"\"\n    time.sleep(0.1)\n    return {\"frame\": 42, \"fps\": 30}\n\ndef main():\n    try:\n        # Connect to Krill daemon\n        with KrillClient(\"vision-processor\") as client:\n            print(\"Connected to Krill daemon\")\n\n            frame_count = 0\n            while True:\n                try:\n                    # Do work\n                    result = process_frame()\n                    frame_count += 1\n\n                    # Send heartbeat every 10 frames\n                    if frame_count % 10 == 0:\n                        client.heartbeat_with_metadata({\n                            \"frames_processed\": str(frame_count),\n                            \"fps\": str(result[\"fps\"])\n                        })\n                        print(f\"Heartbeat sent (frame {frame_count})\")\n\n                except KeyboardInterrupt:\n                    print(\"\\nShutting down...\")\n                    break\n\n    except ConnectionError as e:\n        print(f\"Cannot connect to Krill daemon: {e}\", file=sys.stderr)\n        print(\"Make sure Krill daemon is running\", file=sys.stderr)\n        return 1\n\n    except SendError as e:\n        print(f\"Failed to send heartbeat: {e}\", file=sys.stderr)\n        return 1\n\n    return 0\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n</code></pre>"},{"location":"sdk-installation/#api-reference","title":"API Reference","text":"<p>KrillClient (Synchronous)</p> <pre><code># Constructor\nclient = KrillClient(service_name: str, socket_path: str = \"/tmp/krill.sock\")\n\n# Methods\nclient.heartbeat()  # Send heartbeat\nclient.heartbeat_with_metadata(metadata: dict[str, str])  # With metadata\nclient.report_degraded(reason: str)  # Report degraded status\nclient.report_healthy()  # Report healthy status\nclient.close()  # Close connection\n\n# Context manager\nwith KrillClient(\"service-name\") as client:\n    client.heartbeat()\n</code></pre> <p>AsyncKrillClient (Asynchronous)</p> <pre><code># Constructor (async)\nclient = await AsyncKrillClient.connect(service_name: str, socket_path: str = \"/tmp/krill.sock\")\n\n# Methods (all async)\nawait client.heartbeat()\nawait client.heartbeat_with_metadata(metadata: dict[str, str])\nawait client.report_degraded(reason: str)\nawait client.report_healthy()\nawait client.close()\n\n# Context manager (async)\nasync with await AsyncKrillClient.connect(\"service-name\") as client:\n    await client.heartbeat()\n</code></pre>"},{"location":"sdk-installation/#rust-sdk","title":"Rust SDK","text":""},{"location":"sdk-installation/#installation_1","title":"Installation","text":"<p>Add to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nkrill-sdk-rust = { path = \"../krill/crates/krill-sdk-rust\" }\ntokio = { version = \"1\", features = [\"full\"] }\n</code></pre> <p>Or if published to crates.io:</p> <pre><code>[dependencies]\nkrill-sdk-rust = \"0.1\"\ntokio = { version = \"1\", features = [\"full\"] }\n</code></pre>"},{"location":"sdk-installation/#requirements_1","title":"Requirements","text":"<ul> <li>Rust 1.70 or later</li> <li>Tokio runtime (for async)</li> <li>Unix-like system (Linux, macOS)</li> </ul>"},{"location":"sdk-installation/#basic-usage_1","title":"Basic Usage","text":"<pre><code>use krill_sdk_rust::KrillClient;\nuse std::time::Duration;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Connect to Krill daemon\n    let client = KrillClient::new(\"my-service\").await?;\n\n    loop {\n        // Do your work\n        process_data().await?;\n\n        // Send heartbeat\n        client.heartbeat().await?;\n\n        tokio::time::sleep(Duration::from_secs(1)).await;\n    }\n}\n</code></pre>"},{"location":"sdk-installation/#configuration-in-recipe_1","title":"Configuration in Recipe","text":"<pre><code>services:\n  my-service:\n    execute:\n      type: shell\n      command: ./target/release/my-service\n    health_check:\n      type: heartbeat\n      timeout: 5s\n</code></pre>"},{"location":"sdk-installation/#complete-example_1","title":"Complete Example","text":"<pre><code>use krill_sdk_rust::{KrillClient, KrillError};\nuse std::time::Duration;\nuse tokio::time;\n\nasync fn process_data() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Simulate work\n    time::sleep(Duration::from_millis(100)).await;\n    Ok(())\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\"Starting vision processor...\");\n\n    // Connect to Krill daemon\n    let client = match KrillClient::new(\"vision-processor\").await {\n        Ok(c) =&gt; c,\n        Err(e) =&gt; {\n            eprintln!(\"Cannot connect to Krill daemon: {}\", e);\n            eprintln!(\"Make sure Krill daemon is running\");\n            return Err(e.into());\n        }\n    };\n\n    println!(\"Connected to Krill daemon\");\n\n    let mut frame_count = 0u64;\n\n    loop {\n        // Process frame\n        if let Err(e) = process_data().await {\n            eprintln!(\"Error processing data: {}\", e);\n            continue;\n        }\n\n        frame_count += 1;\n\n        // Send heartbeat every 10 frames\n        if frame_count % 10 == 0 {\n            let mut metadata = std::collections::HashMap::new();\n            metadata.insert(\"frames_processed\".to_string(), frame_count.to_string());\n            metadata.insert(\"fps\".to_string(), \"30\".to_string());\n\n            if let Err(e) = client.heartbeat_with_metadata(metadata).await {\n                eprintln!(\"Failed to send heartbeat: {}\", e);\n                return Err(e.into());\n            }\n\n            println!(\"Heartbeat sent (frame {})\", frame_count);\n        }\n    }\n}\n</code></pre>"},{"location":"sdk-installation/#api-reference_1","title":"API Reference","text":"<pre><code>// Constructor (async)\nlet client = KrillClient::new(service_name: &amp;str).await?;\nlet client = KrillClient::with_socket_path(service_name: &amp;str, socket_path: &amp;str).await?;\n\n// Methods (all async)\nclient.heartbeat().await?;\nclient.heartbeat_with_metadata(metadata: HashMap&lt;String, String&gt;).await?;\nclient.report_degraded(reason: &amp;str).await?;\nclient.report_healthy().await?;\n</code></pre>"},{"location":"sdk-installation/#c-sdk","title":"C++ SDK","text":""},{"location":"sdk-installation/#installation_2","title":"Installation","text":"<p>The C++ SDK is header-only. Just include the header:</p> <pre><code>#include \"krill/sdk/krill-cpp/krill.hpp\"\n</code></pre>"},{"location":"sdk-installation/#requirements_2","title":"Requirements","text":"<ul> <li>C++11 or later</li> <li>No external dependencies</li> <li>Unix-like system (Linux, macOS)</li> </ul>"},{"location":"sdk-installation/#basic-usage_2","title":"Basic Usage","text":"<pre><code>#include \"krill.hpp\"\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    try {\n        // Connect to Krill daemon\n        krill::Client client(\"my-service\");\n\n        while (true) {\n            // Do your work\n            process_data();\n\n            // Send heartbeat\n            client.heartbeat();\n\n            std::this_thread::sleep_for(std::chrono::seconds(1));\n        }\n\n    } catch (const krill::KrillError&amp; e) {\n        std::cerr &lt;&lt; \"Error: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"sdk-installation/#configuration-in-recipe_2","title":"Configuration in Recipe","text":"<pre><code>services:\n  my-service:\n    execute:\n      type: shell\n      command: ./build/my-service\n    health_check:\n      type: heartbeat\n      timeout: 5s\n</code></pre>"},{"location":"sdk-installation/#complete-example_2","title":"Complete Example","text":"<pre><code>#include \"krill.hpp\"\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;map&gt;\n\nvoid process_frame() {\n    // Simulate work\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n}\n\nint main() {\n    std::cout &lt;&lt; \"Starting vision processor...\" &lt;&lt; std::endl;\n\n    try {\n        // Connect to Krill daemon\n        krill::Client client(\"vision-processor\");\n        std::cout &lt;&lt; \"Connected to Krill daemon\" &lt;&lt; std::endl;\n\n        uint64_t frame_count = 0;\n\n        while (true) {\n            // Process frame\n            process_frame();\n            frame_count++;\n\n            // Send heartbeat every 10 frames\n            if (frame_count % 10 == 0) {\n                std::map&lt;std::string, std::string&gt; metadata;\n                metadata[\"frames_processed\"] = std::to_string(frame_count);\n                metadata[\"fps\"] = \"30\";\n\n                client.heartbeat_with_metadata(metadata);\n                std::cout &lt;&lt; \"Heartbeat sent (frame \" &lt;&lt; frame_count &lt;&lt; \")\" &lt;&lt; std::endl;\n            }\n        }\n\n    } catch (const krill::KrillError&amp; e) {\n        std::cerr &lt;&lt; \"Error: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n        std::cerr &lt;&lt; \"Make sure Krill daemon is running\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"sdk-installation/#compilation","title":"Compilation","text":"<pre><code># Simple compilation\ng++ -std=c++11 -I/path/to/krill/sdk -o my-service my-service.cpp\n\n# With optimizations\ng++ -std=c++11 -O3 -I/path/to/krill/sdk -o my-service my-service.cpp\n\n# With CMake\n# CMakeLists.txt:\ncmake_minimum_required(VERSION 3.10)\nproject(MyService)\n\nset(CMAKE_CXX_STANDARD 11)\n\ninclude_directories(/path/to/krill/sdk)\n\nadd_executable(my-service my-service.cpp)\n</code></pre>"},{"location":"sdk-installation/#api-reference_2","title":"API Reference","text":"<pre><code>// Constructor\nkrill::Client client(const std::string&amp; service_name);\nkrill::Client client(const std::string&amp; service_name, const std::string&amp; socket_path);\n\n// Methods\nclient.heartbeat();  // Send heartbeat\nclient.heartbeat_with_metadata(const std::map&lt;std::string, std::string&gt;&amp; metadata);\nclient.report_degraded(const std::string&amp; reason);\nclient.report_healthy();\n\n// All methods may throw krill::KrillError\n</code></pre>"},{"location":"sdk-installation/#when-to-use-sdks","title":"When to Use SDKs","text":""},{"location":"sdk-installation/#use-sdk-heartbeats-when","title":"\u2705 Use SDK Heartbeats When:","text":"<ul> <li>You control the service code</li> <li>You need accurate internal state monitoring</li> <li>Service has complex initialization</li> <li>You want to report degraded states</li> <li>Service does async/background work</li> </ul>"},{"location":"sdk-installation/#dont-use-sdk-heartbeats-when","title":"\u274c Don't Use SDK Heartbeats When:","text":"<ul> <li>You can't modify the service code</li> <li>Service is a third-party binary</li> <li>Simple TCP/HTTP check is sufficient</li> <li>Service has no long-running process</li> </ul> <p>Alternatives: - TCP health check - For services exposing ports - HTTP health check - For web services/APIs - Script health check - For custom validation</p>"},{"location":"sdk-installation/#examples","title":"Examples","text":""},{"location":"sdk-installation/#ros2-node-with-heartbeat","title":"ROS2 Node with Heartbeat","text":"<pre><code>#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom krill import KrillClient\n\nclass MyNode(Node):\n    def __init__(self):\n        super().__init__('my_node')\n\n        # Initialize Krill client\n        self.krill_client = KrillClient(\"my-ros-node\")\n\n        # Create timer for heartbeats (every 2 seconds)\n        self.heartbeat_timer = self.create_timer(2.0, self.send_heartbeat)\n\n        # Your ROS2 logic here\n        self.create_subscription(...)\n\n    def send_heartbeat(self):\n        try:\n            self.krill_client.heartbeat()\n            self.get_logger().debug(\"Heartbeat sent\")\n        except Exception as e:\n            self.get_logger().error(f\"Failed to send heartbeat: {e}\")\n\ndef main():\n    rclpy.init()\n    node = MyNode()\n\n    try:\n        rclpy.spin(node)\n    finally:\n        node.krill_client.close()\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>Recipe:</p> <pre><code>services:\n  my-ros-node:\n    execute:\n      type: shell\n      command: python3 my_node.py\n    health_check:\n      type: heartbeat\n      timeout: 5s\n</code></pre>"},{"location":"sdk-installation/#data-processing-pipeline","title":"Data Processing Pipeline","text":"<pre><code>from krill import KrillClient\nimport time\nimport queue\n\ndef main():\n    with KrillClient(\"data-processor\") as client:\n        work_queue = queue.Queue()\n\n        while True:\n            try:\n                # Get work with timeout\n                item = work_queue.get(timeout=2.0)\n\n                # Process item\n                result = process(item)\n\n                # Only heartbeat when actively processing\n                client.heartbeat_with_metadata({\n                    \"queue_size\": str(work_queue.qsize()),\n                    \"items_processed\": str(result.count)\n                })\n\n            except queue.Empty:\n                # No work available - don't heartbeat\n                # This will cause service to be marked unhealthy\n                # if no work arrives within the timeout\n                pass\n</code></pre>"},{"location":"sdk-installation/#microservice-with-health-states","title":"Microservice with Health States","text":"<pre><code>from krill import KrillClient\nfrom enum import Enum\n\nclass HealthState(Enum):\n    HEALTHY = \"healthy\"\n    DEGRADED = \"degraded\"\n    UNHEALTHY = \"unhealthy\"\n\ndef main():\n    with KrillClient(\"api-service\") as client:\n        state = HealthState.HEALTHY\n\n        while True:\n            # Check system resources\n            cpu_usage = get_cpu_usage()\n            memory_usage = get_memory_usage()\n\n            # Determine health state\n            if cpu_usage &gt; 90 or memory_usage &gt; 95:\n                state = HealthState.DEGRADED\n                client.report_degraded(\n                    f\"High resource usage: CPU={cpu_usage}% MEM={memory_usage}%\"\n                )\n            elif cpu_usage &lt; 70 and memory_usage &lt; 80:\n                if state == HealthState.DEGRADED:\n                    client.report_healthy()\n                    state = HealthState.HEALTHY\n                client.heartbeat()\n\n            time.sleep(1)\n</code></pre>"},{"location":"sdk-installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"sdk-installation/#connection-failed","title":"Connection Failed","text":"<p>Error: <code>Cannot connect to Krill daemon</code></p> <p>Solutions: 1. Verify Krill daemon is running: <code>ps aux | grep krill</code> 2. Check socket path is correct (default: <code>/tmp/krill.sock</code>) 3. Ensure service name matches recipe configuration 4. Check file permissions on socket</p>"},{"location":"sdk-installation/#heartbeats-not-received","title":"Heartbeats Not Received","text":"<p>Symptoms: Service always shows as unhealthy</p> <p>Solutions: 1. Verify heartbeat timeout in recipe is sufficient 2. Check service is actually calling <code>heartbeat()</code> 3. Review service logs for SDK errors 4. Ensure heartbeat frequency &lt; timeout</p>"},{"location":"sdk-installation/#service-marked-unhealthy-during-startup","title":"Service Marked Unhealthy During Startup","text":"<p>Symptoms: Service fails health check immediately</p> <p>Solutions: 1. Increase health check timeout in recipe 2. Send first heartbeat as soon as possible 3. Consider using <code>started</code> dependency instead of <code>healthy</code></p>"},{"location":"examples/","title":"Examples","text":"<p>Runnable examples are in the <code>examples/</code> directory of the repository. Each one demonstrates a different executor type or orchestration pattern.</p> <ul> <li> <p> Pixi Services</p> <p>Three Python services with DAG dependencies, health checks, and restart policies.</p> <p> View example</p> </li> <li> <p> ROS2 Talker / Listener</p> <p>Minimal ROS2 example using Pixi to run talker and listener nodes.</p> <p> View example</p> </li> <li> <p> ROS2 Navigation Stack</p> <p>Full autonomous robot stack: lidar, camera, SLAM, navigation, and dashboard.</p> <p> View example</p> </li> <li> <p> Shell Scripts</p> <p>Simple shell scripts showing dependency chains and failure handling.</p> <p> View example</p> </li> <li> <p> Docker</p> <p>Running a containerised service with volumes, ports, and networking.</p> <p> View example</p> </li> </ul>"},{"location":"examples/docker/","title":"Docker","text":"<p>Running a containerised service with volumes, ports, and networking.</p>"},{"location":"examples/docker/#recipe","title":"Recipe","text":"examples/krill-docker.yaml<pre><code>version: \"1\"\nname: robot\nlog_dir: ~/.krill/logs\n\nservices:\n  my-service:\n    execute:\n      type: docker\n      image: \"nginx:latest\"\n      volumes:\n        - \"./docker:/container/app\"\n      ports:\n        - \"8080:80\"\n      privileged: false\n      network: \"bridge\"\n</code></pre>"},{"location":"examples/docker/#running","title":"Running","text":"<pre><code>krill up examples/krill-docker.yaml\n</code></pre> <p>Open http://localhost:8080 to see nginx running.</p>"},{"location":"examples/docker/#key-concepts","title":"Key Concepts","text":"<ul> <li><code>type: docker</code> \u2014 Krill manages <code>docker run</code> for you.</li> <li><code>volumes</code> \u2014 mount host paths into the container (<code>host:container</code> or <code>host:container:ro</code>).</li> <li><code>ports</code> \u2014 publish container ports to the host.</li> <li><code>network</code> \u2014 set the Docker network mode (<code>bridge</code>, <code>host</code>, or a named network).</li> <li><code>privileged</code> \u2014 enable privileged mode for hardware access (use with care).</li> </ul> <p>Docker services can be mixed with any other executor type in the same recipe \u2014 see the ROS2 Navigation example for a combined setup.</p>"},{"location":"examples/pixi-services/","title":"Pixi Services","text":"<p>Three Python services orchestrated as a DAG, demonstrating health checks, restart policies, and the Krill Python SDK.</p>"},{"location":"examples/pixi-services/#architecture","title":"Architecture","text":"<pre><code>data-processor          (no dependencies, always-restart)\n       \u2502\n       \u25bc healthy\ndata-analyzer           (restart on-failure, max 3)\n       \u2502\n       \u25bc healthy\ndecision-controller     (critical, restart on-failure, max 3)\n</code></pre>"},{"location":"examples/pixi-services/#recipe","title":"Recipe","text":"examples/krill-pixi.yaml<pre><code>version: \"1\"\nname: krill-pixi\n\nenv:\n  ROBOT_ID: \"pixi-001\"\n  LOG_LEVEL: \"info\"\n\nservices:\n  data-processor:\n    execute:\n      type: pixi\n      task: run-processor\n      environment: default\n      working_dir: ./services/data-processor\n    dependencies: []\n    health_check:\n      type: heartbeat\n      timeout: 10s\n    policy:\n      restart: always\n      restart_delay: 5s\n\n  data-analyzer:\n    execute:\n      type: pixi\n      task: run-analyzer\n      environment: default\n      working_dir: ./services/data-analyzer\n    dependencies:\n      - data-processor: healthy\n    health_check:\n      type: heartbeat\n      timeout: 10s\n    policy:\n      restart: on-failure\n      max_restarts: 3\n      restart_delay: 5s\n\n  decision-controller:\n    execute:\n      type: pixi\n      task: run-controller\n      environment: default\n      working_dir: ./services/decision-controller\n    dependencies:\n      - data-processor: healthy\n      - data-analyzer: healthy\n    critical: true\n    health_check:\n      type: heartbeat\n      timeout: 15s\n    policy:\n      restart: on-failure\n      max_restarts: 3\n      restart_delay: 5s\n</code></pre>"},{"location":"examples/pixi-services/#running","title":"Running","text":"<pre><code># Install pixi environments (first time)\ncd examples/services\nfor d in data-processor data-analyzer decision-controller; do\n  (cd \"$d\" &amp;&amp; pixi install)\ndone\n\n# Start\ncd ../..\nkrill up examples/krill-pixi.yaml\n</code></pre>"},{"location":"examples/pixi-services/#what-to-expect","title":"What to Expect","text":"<ol> <li>data-processor starts first and begins sending heartbeats.</li> <li>Once healthy, data-analyzer starts. It occasionally reports degraded status.</li> <li>Once both are healthy, decision-controller starts.</li> </ol>"},{"location":"examples/pixi-services/#try-it","title":"Try It","text":"Scenario Command Expected Kill processor <code>kill &lt;pid&gt;</code> Restarts immediately, dependents keep running Kill analyzer <code>kill &lt;pid&gt;</code> Restarts up to 3 times, controller stops Kill controller 3+ times <code>kill &lt;pid&gt;</code> (repeat) Emergency stop \u2014 all services shut down"},{"location":"examples/pixi-services/#key-concepts","title":"Key Concepts","text":"<ul> <li><code>type: pixi</code> \u2014 runs a pixi task inside a managed environment</li> <li><code>dependencies: [svc: healthy]</code> \u2014 waits for heartbeat confirmation before starting</li> <li><code>critical: true</code> \u2014 failure of this service triggers a full emergency stop</li> </ul>"},{"location":"examples/ros2-navigation/","title":"ROS2 Navigation Stack","text":"<p>A full autonomous robot stack: lidar, camera, SLAM, navigation, and a web dashboard.</p>"},{"location":"examples/ros2-navigation/#architecture","title":"Architecture","text":"<pre><code>lidar \u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u251c\u2500\u2500\u25b6 slam \u2500\u2500\u25b6 navigation (critical) \u2500\u2500\u25b6 dashboard\ncamera \u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/ros2-navigation/#recipe","title":"Recipe","text":"examples/krill-ros2-navigation.yaml<pre><code>version: \"1\"\nname: autonomous-robot\nlog_dir: ~/.krill/logs\n\nenv:\n  ROS_DOMAIN_ID: \"42\"\n  ROS_LOCALHOST_ONLY: \"0\"\n\nservices:\n  lidar:\n    execute:\n      type: ros2\n      package: ldlidar_ros2\n      launch_file: ldlidar.launch.py\n    health_check:\n      type: tcp\n      port: 4048\n    policy:\n      restart: on-failure\n      max_restarts: 3\n\n  camera:\n    execute:\n      type: ros2\n      package: realsense2_camera\n      launch_file: rs_launch.py\n      launch_args:\n        enable_depth: \"true\"\n        enable_color: \"true\"\n    dependencies:\n      - lidar\n    health_check:\n      type: tcp\n      port: 8554\n\n  slam:\n    execute:\n      type: ros2\n      package: slam_toolbox\n      launch_file: online_async_launch.py\n    dependencies:\n      - lidar: healthy\n      - camera: healthy\n    health_check:\n      type: heartbeat\n      timeout: 5s\n\n  navigation:\n    execute:\n      type: ros2\n      package: nav2_bringup\n      launch_file: navigation_launch.py\n    dependencies:\n      - slam: healthy\n    critical: true\n    health_check:\n      type: http\n      port: 8080\n      path: /health\n    policy:\n      restart: always\n      restart_delay: 2s\n\n  dashboard:\n    execute:\n      type: docker\n      image: ghcr.io/robotics/web-ui:latest\n      ports:\n        - \"3000:3000\"\n      volumes:\n        - \"./config:/app/config:ro\"\n      network: host\n    dependencies:\n      - navigation: started\n</code></pre>"},{"location":"examples/ros2-navigation/#key-concepts","title":"Key Concepts","text":"<ul> <li>Mixed executors \u2014 ROS2 launch files alongside a Docker container in the same recipe.</li> <li><code>type: ros2</code> \u2014 launches ROS2 packages directly with <code>launch_args</code>.</li> <li>Health check variety \u2014 TCP for hardware drivers, heartbeat for SLAM, HTTP for navigation.</li> <li><code>critical: true</code> \u2014 navigation failure triggers emergency stop of the entire stack.</li> <li><code>network: host</code> \u2014 the dashboard container shares the host network to reach ROS2 topics.</li> </ul>"},{"location":"examples/ros2-talker-listener/","title":"ROS2 Talker / Listener","text":"<p>A minimal ROS2 example using Pixi to run the standard <code>demo_nodes_cpp</code> talker and listener.</p>"},{"location":"examples/ros2-talker-listener/#recipe","title":"Recipe","text":"examples/krill-ros2.yaml<pre><code>version: \"1\"\nname: robot\nlog_dir: ~/.krill/logs\n\nenv:\n  ROBOT_ID: robot-001\n  ROS_DOMAIN_ID: \"42\"\n\nservices:\n  ros_talker:\n    execute:\n      type: pixi\n      task: talker\n      working_dir: ./ros2\n    dependencies: []\n    critical: true\n    policy:\n      restart: always\n      max_restarts: 3\n      restart_delay: 5s\n\n  ros_listener:\n    execute:\n      type: pixi\n      task: listener\n      working_dir: ./ros2\n    dependencies:\n      - ros_talker\n    policy:\n      restart: always\n      max_restarts: 3\n      restart_delay: 5s\n</code></pre> <p>The <code>examples/ros2/pixi.toml</code> defines the tasks using the <code>robostack-jazzy</code> channel:</p> examples/ros2/pixi.toml<pre><code>[project]\nname = \"krill-ros2-example\"\nchannels = [\"robostack-jazzy\", \"conda-forge\"]\nplatforms = [\"linux-64\", \"osx-arm64\"]\n\n[dependencies]\nros-jazzy-demo-nodes-cpp = \"*\"\n\n[tasks]\ntalker = \"ros2 run demo_nodes_cpp talker\"\nlistener = \"ros2 run demo_nodes_cpp listener\"\n</code></pre>"},{"location":"examples/ros2-talker-listener/#running","title":"Running","text":"<pre><code>cd examples/ros2 &amp;&amp; pixi install &amp;&amp; cd ../..\nkrill up examples/krill-ros2.yaml\n</code></pre>"},{"location":"examples/ros2-talker-listener/#key-concepts","title":"Key Concepts","text":"<ul> <li>Pixi + ROS2 \u2014 Pixi manages the ROS2 environment so you don't need a system-wide ROS install.</li> <li>Dependency ordering \u2014 the listener waits for the talker to start before launching.</li> <li><code>critical: true</code> \u2014 if the talker dies permanently, the whole stack stops.</li> </ul>"},{"location":"examples/shell-scripts/","title":"Shell Scripts","text":"<p>Simple shell scripts demonstrating dependency chains and failure handling.</p>"},{"location":"examples/shell-scripts/#recipe","title":"Recipe","text":"examples/krill-shell.yaml<pre><code>version: \"1\"\nname: test-shell\nlog_dir: ~/.krill/logs\n\nservices:\n  counter1:\n    execute:\n      type: shell\n      command: bash counter1.sh\n      working_dir: ./scripts/\n    policy:\n      restart: always\n\n  counter2:\n    execute:\n      type: shell\n      command: bash counter2.sh\n      working_dir: ./scripts/\n    dependencies:\n      - counter1\n    policy:\n      restart: always\n\n  fast_counter:\n    execute:\n      type: shell\n      command: bash fast_counter.sh\n      working_dir: ./scripts/\n    policy:\n      restart: always\n\n  logger:\n    execute:\n      type: shell\n      command: bash logger.sh\n      working_dir: ./scripts/\n    dependencies:\n      - counter1\n      - counter2\n    policy:\n      restart: always\n\n  failing_service:\n    execute:\n      type: shell\n      command: bash failing.sh\n      working_dir: ./scripts/\n    policy:\n      restart: on-failure\n      max_restarts: 3\n      restart_delay: 2s\n</code></pre>"},{"location":"examples/shell-scripts/#running","title":"Running","text":"<pre><code>krill up examples/krill-shell.yaml\n</code></pre>"},{"location":"examples/shell-scripts/#what-to-expect","title":"What to Expect","text":"<ul> <li>counter1 and fast_counter start immediately (no dependencies).</li> <li>counter2 starts after counter1 is up.</li> <li>logger starts after both counter1 and counter2.</li> <li>failing_service runs for 5 seconds, exits with code 1, then restarts up to 3 times before giving up.</li> </ul>"},{"location":"examples/shell-scripts/#key-concepts","title":"Key Concepts","text":"<ul> <li><code>type: shell</code> \u2014 runs any shell command.</li> <li><code>restart: on-failure</code> + <code>max_restarts</code> \u2014 automatic recovery with a retry budget.</li> <li>Good starting point for testing Krill without any language-specific tooling.</li> </ul>"}]}